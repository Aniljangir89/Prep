# 0.5 — Introduction to the Compiler, Linker, and Libraries


Continuing our discussion of this diagram from the previous lesson (**0.4 -- Introduction to C++ development**):

---

## The Software Development Process

Let’s discuss steps 

<img src="pictures/1.png" alt="Diagram of the software development process" width="500">


### Step 4: Compiling Your Source Code

To compile C++ source code files, we use a **C++ compiler**. The compiler sequentially processes each source code (`.cpp`) file and performs two key tasks:

1. **Syntax Checking**  
    The compiler checks your C++ code to ensure it follows the rules of the language. If errors are found, it reports them (with line numbers) and aborts compilation until fixed.

2. **Translation to Machine Code**  
    The compiler translates your C++ code into machine language instructions, storing them in an intermediate file called an **object file**. Object files also contain data needed by the linker (step 5) and for debugging (step 7).

> **Object files** are typically named `name.o` or `name.obj`, where `name` matches the original `.cpp` file.

**Example:**  
If your program has 3 `.cpp` files, the compiler generates 3 object files:

```
main.cpp   →   main.obj
utils.cpp  →   utils.obj
math.cpp   →   math.obj
```

<img src="pictures/2.png" alt="Diagram of the software development process" width="500">

> C++ compilers are available for many operating systems. We’ll discuss installation soon.

---

### Step 5: Linking Object Files and Libraries

After successful compilation, the **linker** combines all object files to produce the desired output file (e.g., an executable). This process is called **linking**.

#### Linking Steps

1. **Read Object Files**  
    The linker reads each object file generated by the compiler and checks validity.

2. **Resolve Dependencies**  
    The linker ensures all cross-file dependencies are resolved. For example, if something is defined in one `.cpp` file and used in another, the linker connects them. Unresolved references cause linker errors.

3. **Link Libraries**  
    The linker typically links in one or more **library files**—collections of precompiled code packaged for reuse.

4. **Output File Creation**  
    The linker produces the final output file, usually an executable, but it could be a library file depending on your project setup.

---

<img src="pictures/3.png" alt="Diagram of the software development process" width="500">

### The Standard Library

The **standard library** provides a set of precompiled, reusable code that can be linked into your programs to extend functionality.

---

> **Summary:**  
> - The **compiler** checks and translates your code into object files.  
> - The **linker** combines object files and libraries to create the final output.


---

## 2.1 — Introduction to Functions

**Alex &nbsp;&nbsp; September 28, 2024**

In the last chapter, we defined a function as a collection of statements that execute sequentially. Let’s update our definition:  
A **function** is a reusable sequence of statements designed to do a particular job.

You already know that every executable program must have a function named `main()` (where execution starts). As programs grow, putting all code inside `main()` becomes hard to manage. Functions let us split programs into small, modular chunks that are easier to organize, test, and reuse. Most programs use many functions. The C++ standard library provides many built-in functions, but you’ll often write your own—called **user-defined functions**.

### Functions in Action

Consider this analogy:  
You’re reading a book and remember you need to make a phone call. You put a bookmark in your book, make the call, and then return to the bookmark to continue reading.

C++ programs work similarly. When a function call is encountered, the CPU “bookmarks” the current location, executes the called function, and then returns to the bookmark to resume execution.

#### Nomenclature

- **Caller**: The function initiating the call.
- **Callee**: The function being called.
- **Invocation**: Another term for a function call.

---

### Defining and Calling Functions

The basic syntax for a user-defined function:

```cpp
returnType functionName() // Function header
{
    // Function body
}
```

- **Function header**: Tells the compiler about the function’s existence, name, and return type.
- **Function body**: Contains the statements that define what the function does.

To call a function, use its name followed by parentheses:

```cpp
functionName();
```

> **Note:**  
> A function must be defined before it can be called (we’ll discuss workarounds in lesson 2.7).

#### Example: Defining and Calling a Function

```cpp
#include <iostream> // for std::cout

void doPrint()
{
    std::cout << "In doPrint()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doPrint();                        // Call to doPrint()
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
In doPrint()
Ending main()
```

> **Warning:**  
> Don’t forget the parentheses when calling a function! Omitting them may cause compilation errors or prevent the function from being called.

---

### Calling Functions Multiple Times

Functions can be called as many times as needed:

```cpp
#include <iostream>

void doPrint()
{
    std::cout << "In doPrint()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // First call
    doPrint(); // Second call
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
In doPrint()
In doPrint()
Ending main()
```

---

### Functions Calling Other Functions

Functions can call other functions, creating a chain of calls:

```cpp
#include <iostream>

void doB()
{
    std::cout << "In doB()\n";
}

void doA()
{
    std::cout << "Starting doA()\n";
    doB();
    std::cout << "Ending doA()\n";
}

int main()
{
    std::cout << "Starting main()\n";
    doA();
    std::cout << "Ending main()\n";

    return 0;
}
```

**Output:**
```
Starting main()
Starting doA()
In doB()
Ending doA()
Ending main()
```

---

### Nested Functions Are Not Supported

C++ does **not** support nested function definitions:

```cpp
#include <iostream>

int main()
{
    void foo() // Illegal: nested inside main()
    {
        std::cout << "foo!\n";
    }

    foo();

    return 0;
}
```

**Correct way:**

```cpp
#include <iostream>

void foo()
{
    std::cout << "foo!\n";
}

int main()
{
    foo();

    return 0;
}
```

---

### Metasyntactic Variables

“foo” is a placeholder name often used for demonstration purposes. Other common placeholders include “bar”, “baz”, and words ending in “oo” (e.g., “goo”, “moo”, “boo”).  
For more on the etymology, see [RFC 3092](https://datatracker.ietf.org/doc/html/rfc3092).

---


## 2.2 — Function Return Values (Value-Returning Functions)

**Alex &nbsp;&nbsp; February 5, 2025**

Consider the following program:

```cpp
#include <iostream>

int main()
{
    // get a value from the user
    std::cout << "Enter an integer: ";
    int num{};
    std::cin >> num;

    // print the value doubled
    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

This program is composed of two conceptual parts:  
1. Get a value from the user.  
2. Tell the user what double that value is.

Although this program is simple, what if we wanted to break it into multiple functions? Getting an integer value from the user is a well-defined job, so it would make a good candidate for a function.

### Attempting to Modularize

```cpp
// This program doesn't work
#include <iostream>

void getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;
}

int main()
{
    getValueFromUser(); // Ask user for input

    int num{}; // How do we get the value from getValueFromUser() and use it to initialize this variable?

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

When `getValueFromUser` is called, the user enters an integer, but the value is lost when the function terminates. Variable `num` is never initialized with the user's input, so the program always prints 0.

### Returning Values from Functions

To return a value from a function, two things are needed:
1. The function must specify a return type (not `void`).
2. The function must use a `return` statement to provide the value.

#### Example: Value-Returning Function

```cpp
#include <iostream>

// int is the return type
int returnFive()
{
    return 5; // return the value 5 back to the caller
}

int main()
{
    std::cout << returnFive() << '\n';      // prints 5
    std::cout << returnFive() + 2 << '\n';  // prints 7

    returnFive(); // value is returned but ignored

    return 0;
}
```

**Output:**
```
5
7
```

> **Tip:**  
> If the caller ignores the return value, it is discarded.

### Fixing the Challenge Program

```cpp
#include <iostream>

int getValueFromUser() // returns an integer value
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input; // return the value to the caller
}

int main()
{
    int num{ getValueFromUser() }; // initialize num with the return value

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

Now, `num` is initialized with the user's input, and can be used as needed.

> **Tip:**  
> If you need to use the return value more than once, store it in a variable.

### Revisiting `main()`

- `main()` must return an `int`.
- Explicit calls to `main()` are disallowed.

```cpp
void foo()
{
    main(); // Compile error: main not allowed to be called explicitly
}

void main() // Compile error: main not allowed to have non-int return type
{
    foo();
}
```

> **Note:**  
> Some C++ compilers allow calling `main()` for C compatibility, but avoid doing so.

### Status Codes

The return value from `main()` is called a status code.  
- `0` or `EXIT_SUCCESS` means success.
- `EXIT_FAILURE` means failure.

```cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
```

> **Best practice:**  
> Return `0` or `EXIT_SUCCESS` for successful termination.

### Undefined Behavior: Not Returning a Value

A value-returning function must return a value. Otherwise, undefined behavior results.

```cpp
#include <iostream>

int getValueFromUserUB() // returns int
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    // no return statement
}

int main()
{
    int num{ getValueFromUserUB() }; // undefined behavior

    std::cout << num << " doubled is: " << num * 2 << '\n';

    return 0;
}
```

> **Best practice:**  
> Ensure all non-void functions return a value in all cases.

### Implicit Return from `main()`

If no return statement is provided in `main()`, it implicitly returns `0`.  
However, always explicitly return a value for clarity and consistency.

### Functions Can Only Return a Single Value

A function can only return one value per call.  
The return value can be a literal, a variable, or the result of another function call.

```cpp
// Return value is the integer entered by the user
int getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}
```

### Reusing Functions

Consider this redundant program:

```cpp
#include <iostream>

int main()
{
    int x{};
    std::cout << "Enter an integer: ";
    std::cin >> x;

    int y{};
    std::cout << "Enter an integer: ";
    std::cin >> y;

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```

Let's refactor using `getValueFromUser`:

```cpp
#include <iostream>

int getValueFromUser()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    int x{ getValueFromUser() }; // first call
    int y{ getValueFromUser() }; // second call

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```

**Output:**
```
Enter an integer: 5
Enter an integer: 7
5 + 7 = 12
```

This saves us from duplicating code and reduces the chance of mistakes.

> **Best practice:**  
> Follow DRY: "Don't repeat yourself". Use variables, functions, and loops to minimize redundancy.

### Conclusion

- Return values allow functions to return a single value to the caller.
- Functions help minimize redundancy and improve modularity in programs.
- Always ensure value-returning functions return a value in all cases.
- Use functions to encapsulate reusable logic and follow DRY principles.



## 2.10 — Introduction to the Preprocessor

**Alex &nbsp;&nbsp; March 5, 2025**

When you compile your project, each code file first goes through a **preprocessing phase**. The preprocessor scans your code for **preprocessor directives** (lines starting with `#`) and performs text substitutions or conditional compilation before the compiler sees your code.

### What Does the Preprocessor Do?

- Removes comments and ensures files end with a newline.
- Handles `#include` directives by inserting the contents of included files.
- Processes macros and conditional compilation.

After preprocessing, the result is called a **translation unit**, which is then compiled.

---

### Preprocessor Directives

Preprocessor directives begin with `#` and end with a newline. They are not C++ statements and have their own syntax.

**Examples:**
- `#include <iostream>`
- `#define MY_NAME "Alex"`
- `#ifdef PRINT_JOE`
- `#ifndef PRINT_BOB`
- `#endif`

> **Note:**  
> The final code passed to the compiler contains no preprocessor directives—only their output.

---

### `#include` Directive

The `#include` directive copies the contents of a file (usually a header) into your code.

```cpp
#include <iostream>
```

This replaces the directive with the contents of the `iostream` header before compilation.

---

### Macros: `#define`

Macros allow you to define text substitutions.

**Object-like macros:**
```cpp
#define MY_NAME "Alex"
```
All instances of `MY_NAME` are replaced with `"Alex"`.

**Object-like macros without substitution:**
```cpp
#define USE_YEN
```
This is used for conditional compilation.

> **Best practice:**  
> Macro names should be ALL_UPPERCASE with underscores.

---

### Conditional Compilation

Use conditional directives to include or exclude code:

```cpp
#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n";
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n";
#endif

    return 0;
}
```

- `#ifdef IDENTIFIER` — code is included if IDENTIFIER is defined.
- `#ifndef IDENTIFIER` — code is included if IDENTIFIER is NOT defined.

You can also use `#if defined(IDENTIFIER)` and `#if !defined(IDENTIFIER)`.

---

### Excluding Code: `#if 0`

Use `#if 0` to exclude blocks of code:

```cpp
int main()
{
    std::cout << "Joe\n";

#if 0
    std::cout << "Bob\n";
    std::cout << "Steve\n";
#endif

    return 0;
}
```

Change `#if 0` to `#if 1` to re-enable the code.

---

### Macro Substitution Scope

Macros are processed top-to-bottom in each file. They do not respect C++ scopes (e.g., functions). Macros defined in one file do not affect other files unless included.

**Example:**
```cpp
// Alex.h
#define MY_NAME "Alex"

// main.cpp
#include "Alex.h"
#include <iostream>

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';
    return 0;
}
```

---

### Summary

- The preprocessor handles directives before compilation.
- Use `#include` for headers, `#define` for macros, and conditional directives for selective compilation.
- Macros are global within a file and do not respect C++ scopes.
- Prefer modern C++ features over macros when possible.

---

## 4.12 — Introduction to Type Conversion and `static_cast`

**Alex &nbsp;&nbsp; March 3, 2025**

### Implicit Type Conversion

C++ automatically converts values between fundamental types when needed. This is called *implicit type conversion*. For example:

```cpp
#include <iostream>

void print(double x) // expects a double
{
    std::cout << x << '\n';
}

int main()
{
    print(5); // int 5 is implicitly converted to double 5.0
    return 0;
}
```

Output:
```
5
```
> Floating-point values with no fractional part print without decimals (e.g., 5.0 prints as 5).

Implicit conversion does not modify the original value or variable—it produces a new temporary value of the target type.

### Implicit Conversion Warnings

Some conversions may lose information, such as converting a `double` to an `int`:

```cpp
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print(5.5); // double 5.5 implicitly converted to int 5 (fractional part lost)
    return 0;
}
```

Output:
```
5
```
> The compiler will warn about possible data loss. Prefer brace initialization to catch unsafe conversions:

```cpp
int x{5.5}; // error: double to int not safe
```

### Explicit Type Conversion with `static_cast`

To explicitly convert between types, use `static_cast`:

```cpp
#include <iostream>

void print(int x)
{
    std::cout << x << '\n';
}

int main()
{
    print(static_cast<int>(5.5)); // explicit conversion, no warning
    return 0;
}
```

### Using `static_cast` to Convert `char` to `int`

```cpp
#include <iostream>

int main()
{
    char ch{97}; // ASCII for 'a'
    std::cout << ch << " has value " << static_cast<int>(ch) << '\n';
    return 0;
}
```

Output:
```
a has value 97
```

### Sign Conversions

You can convert between signed and unsigned types:

```cpp
#include <iostream>

int main()
{
    unsigned int u1{5};
    int s1{static_cast<int>(u1)};
    std::cout << s1 << '\n'; // prints 5

    int s2{5};
    unsigned int u2{static_cast<unsigned int>(s2)};
    std::cout << u2 << '\n'; // prints 5
    return 0;
}
```

If the value cannot be represented in the destination type, modulo wrapping occurs:

```cpp
#include <iostream>

int main()
{
    int s{-1};
    std::cout << static_cast<unsigned int>(s) << '\n'; // prints 4294967295

    unsigned int u{4294967295};
    std::cout << static_cast<int>(u) << '\n'; // prints -1 (C++20)
    return 0;
}
```

### `std::int8_t` and `std::uint8_t` Behave Like `char`

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myInt{65};
    std::cout << myInt << '\n'; // prints 'A' on most systems
    std::cout << static_cast<int>(myInt) << '\n'; // always prints 65
    return 0;
}
```

Input may also be affected:

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::cout << "Enter a number between 0 and 127: ";
    std::int8_t myInt{};
    std::cin >> myInt;
    std::cout << "You entered: " << static_cast<int>(myInt) << '\n';
    return 0;
}
```

Sample run:
```
Enter a number between 0 and 127: 35
You entered: 51
```
> Input is interpreted as characters, not numbers.

### Summary

- Implicit conversions happen automatically, but may lose data.
- Use `static_cast` for explicit conversions and to suppress warnings.
- Some types (like `std::int8_t`) may behave unexpectedly due to being treated as `char`.
- Prefer brace initialization to catch unsafe conversions.
- Modulo wrapping occurs when converting values outside the destination type's range.


## 5.1 — Constant Variables (Named Constants)

**Alex &nbsp;&nbsp; October 17, 2024**

### Introduction to Constants

A constant is a value that cannot be changed during program execution. C++ supports two kinds of constants:

- **Named constants**: Associated with an identifier (symbolic constants).
- **Literal constants**: Not associated with an identifier.

This lesson covers named constants via constant variables. Object-like macros and enumerated constants are discussed elsewhere.

---

### Defining Constant Variables

A constant variable is a variable whose value cannot be changed after initialization. Use the `const` keyword to declare a constant variable:

```cpp
const double gravity { 9.8 };  // preferred style
int const sidesInSquare { 4 }; // "east const" style (less common)
```

**Best practice:**  
Place `const` before the type for readability.

---

### Initialization Requirement

Constant variables must be initialized when defined and cannot be assigned new values:

```cpp
int main()
{
    const double gravity; // error: must be initialized
    gravity = 9.9;        // error: cannot assign to const

    return 0;
}
```

You can initialize a const variable from another variable:

```cpp
#include <iostream>

int main()
{
    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    const int constAge { age }; // initialized from non-const

    age = 5;      // ok
    constAge = 6; // error

    return 0;
}
```

---

### Naming Conventions

Common conventions for const variable names:

- ALL_UPPERCASE (e.g., `EARTH_GRAVITY`)
- Intercapped with 'k' prefix (e.g., `kEarthGravity`)
- Regular variable naming (e.g., `earthGravity`)

**Best practice:**  
Use the same naming convention as for non-const variables.

---

### Const Function Parameters

Function parameters can be made const:

```cpp
#include <iostream>

void printInt(const int x)
{
    std::cout << x << '\n';
}

int main()
{
    printInt(5);
    printInt(6);

    return 0;
}
```

**Best practice:**  
Do not use `const` for value parameters.

---

### Const Return Values

You can declare a function's return value as const:

```cpp
#include <iostream>

const int getValue()
{
    return 5;
}

int main()
{
    std::cout << getValue() << '\n';
    return 0;
}
```

For fundamental types, the `const` qualifier on return values is ignored.

**Best practice:**  
Do not use `const` when returning by value.

---

### Why Use Constant Variables?

- Prevents accidental modification.
- Enables compiler optimizations.
- Reduces program complexity.

**Best practice:**  
Make variables constant whenever possible (except for value parameters and value return types).

---

### Object-like Macros as Named Constants

Macros can also define named constants:

```cpp
#include <iostream>
#define MY_NAME "Alex"

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';
    return 0;
}
```

---

### Prefer Constant Variables Over Macros

Macros do not follow C++ scoping rules and can cause unexpected substitutions and errors:

```cpp
#include <iostream>

void someFcn()
{
    #define gravity 9.8
}

void printGravity(double gravity)
{
    std::cout << "gravity: " << gravity << '\n';
}

int main()
{
    printGravity(3.71);
    return 0;
}
```

**Best practice:**  
Prefer constant variables over macros for named constants.

---

### Sharing Constants Across Multiple Files

For global constants used throughout a program, declare them in a central location. See lesson 7.10 for details.

---

### Type Qualifiers

A type qualifier modifies how a type behaves. C++ has two: `const` and `volatile`.

- **cv-unqualified type**: No qualifiers (e.g., `int`)
- **cv-qualified type**: With qualifiers (e.g., `const int`)

---

**Joke:**  
Q: How do you know if a C++ developer is qualified?  
A: You look at their CV.


## 7.2 — User-defined namespaces and the scope resolution operator

**Alex &nbsp;&nbsp; June 28, 2024**

Namespaces help prevent naming collisions by grouping identifiers into named scopes. As projects grow, the risk of collisions increases, so using namespaces is essential for modular code.

### Defining a Namespace

Use the `namespace` keyword followed by an identifier and curly braces:

```cpp
namespace MyNamespace
{
    int value{ 42 };
    void printValue()
    {
        std::cout << value << '\n';
    }
}
```

### Accessing Namespace Members

Use the scope resolution operator `::` to access members:

```cpp
std::cout << MyNamespace::value << '\n';
MyNamespace::printValue();
```

### Example: Resolving Naming Collisions

Suppose two files define functions with the same name:

```cpp
namespace Foo
{
    int doSomething(int x, int y) { return x + y; }
}

namespace Goo
{
    int doSomething(int x, int y) { return x - y; }
}

int main()
{
    std::cout << Foo::doSomething(4, 3) << '\n'; // 7
    std::cout << Goo::doSomething(4, 3) << '\n'; // 1
    return 0;
}
```

### Scope Resolution Operator with Global Namespace

Prefixing with `::` accesses the global namespace:

```cpp
void print() { std::cout << "Global\n"; }

namespace Foo
{
    void print() { std::cout << "Foo\n"; }
    void callPrints()
    {
        print();    // Foo::print()
        ::print();  // global print()
    }
}
```

### Forward Declarations in Namespaces

Forward declarations must be inside the same namespace:

```cpp
// add.h
namespace Math
{
    int add(int x, int y);
}

// add.cpp
namespace Math
{
    int add(int x, int y) { return x + y; }
}
```

### Multiple Namespace Blocks

You can extend a namespace in multiple places/files:

```cpp
namespace Math
{
    constexpr double pi{ 3.14159 };
}

namespace Math
{
    constexpr double e{ 2.71828 };
}
```

### Nested Namespaces

Namespaces can be nested:

```cpp
namespace Company
{
    namespace Project
    {
        void run();
    }
}

// C++17 style
namespace Company::Project
{
    void run() { /* ... */ }
}
```

### Namespace Aliases

Shorten long namespace names:

```cpp
namespace LongName::SubName
{
    void func();
}

namespace LN = LongName::SubName;

LN::func(); // calls LongName::SubName::func()
```

### Best Practices

- Use namespaces to avoid naming collisions.
- Prefer capitalized namespace names for user-defined namespaces.
- Avoid extending the `std` namespace.
- Limit nesting to three levels or fewer.
- Namespace library code for distribution.

---

## 7.3 — Local variables

**Alex &nbsp;&nbsp; June 9, 2024**

In lesson 2.5 -- Introduction to local scope, we introduced local variables, which are variables that are defined inside a function (including function parameters).

It turns out that C++ actually doesn’t have a single attribute that defines a variable as being a local variable. Instead, local variables have several different properties that differentiate how these variables behave from other kinds of (non-local) variables. We’ll explore these properties in this and upcoming lessons.

### Scope of Local Variables

An identifier’s scope determines where it can be accessed within the source code. When an identifier can be accessed, it is *in scope*. When it cannot, it is *out of scope*. Scope is a compile-time property, and using an identifier out of scope causes a compile error.

Local variables have **block scope**: they are in scope from their point of definition to the end of the block in which they are defined.

```cpp
int main()
{
    int i { 5 };      // i enters scope here
    double d { 4.0 }; // d enters scope here

    return 0;
} // d and i go out of scope here
```

Function parameters are also considered part of the function body block's scope:

```cpp
int max(int x, int y) // x and y enter scope here
{
    int max{ (x > y) ? x : y }; // max enters scope here
    return max;
} // max, y, and x leave scope here
```

### Unique Names Within Scope

Variable names must be unique within a given scope:

```cpp
void someFunction(int x)
{
    int x{}; // error: name collision with function parameter
}
```

### Automatic Storage Duration

Local variables have **automatic storage duration**: they are created at the point of definition and destroyed at the end of the block.

```cpp
int main()
{
    int i { 5 };      // created and initialized here
    double d { 4.0 }; // created and initialized here

    return 0;
} // destroyed here
```

Local variables are sometimes called *automatic variables*.

### Local Variables in Nested Blocks

Local variables can be defined inside nested blocks:

```cpp
int main()
{
    int x { 5 }; // x enters scope and is created here

    { // nested block
        int y { 7 }; // y enters scope and is created here
        std::cout << x << " + " << y << " = " << x + y << '\n';
    } // y goes out of scope and is destroyed here

    // y cannot be used here

    return 0;
} // x goes out of scope and is destroyed here
```

Variables defined in the outer block are visible inside nested blocks.

### No Linkage for Local Variables

Local variables have **no linkage**: each declaration refers to a unique object.

```cpp
int main()
{
    int x { 2 }; // local variable, no linkage

    {
        int x { 3 }; // refers to a different object than the previous x
    }

    return 0;
}
```

Scope determines where a single identifier can be used; linkage determines whether multiple declarations refer to the same object.

### Define Variables in the Most Limited Scope

If a variable is only used within a nested block, define it inside that block:

```cpp
int main()
{
    {
        int y { 5 };
        std::cout << y << '\n';
    }
    // y cannot be used here

    return 0;
}
```

If a variable is needed in an outer block, declare it there:

```cpp
int main()
{
    int y { 5 };

    {
        int x{};
        std::cin >> x;
        if (x == 4)
            y = 4;
    }

    std::cout << y;

    return 0;
}
```

### Best Practice

Define variables in the most limited existing scope. Avoid creating new blocks solely to limit variable scope; consider using functions instead.

